package ViewModel;

import Model.IModel;
import algorithms.search.AState;
import javafx.beans.property.*;

import java.io.File;
import java.io.IOException;
import java.util.List;

/**
 * ViewModel class for connecting the View and Model layers
 * in the MVVM architecture. Responsible for exposing properties
 * and delegating logic to the underlying model.
 */
public class MyViewModel {

    private final IModel model;

    // Properties for data binding with the View (JavaFX UI)
    private final IntegerProperty playerRow = new SimpleIntegerProperty();
    private final IntegerProperty playerCol = new SimpleIntegerProperty();
    private final ObjectProperty<int[][]> maze = new SimpleObjectProperty<>();

    /**
     * Constructor that receives the Model implementation.
     * @param model the model to be wrapped and used.
     */
    public MyViewModel(IModel model) {
        this.model = model;
    }

    /**
     * Generates a new maze of the given dimensions using the model.
     * Updates the maze property and character position accordingly.
     * @param rows number of rows in the maze
     * @param cols number of columns in the maze
     */
    public void generateMaze(int rows, int cols) {
        model.generateMaze(rows, cols);
        maze.set(model.getMaze());
        updateCharacterPosition();
    }

    /**
     * Triggers maze solving in the model.
     */
    public void solveMaze() {
        model.solveMaze();
    }

    /**
     * Moves the player in the given direction (e.g., "UP", "DOWN").
     * After movement, updates the character position properties.
     * @param direction the move direction string
     */
    public void moveCharacter(String direction) {
        model.moveCharacter(direction);
        updateCharacterPosition();
    }

    /**
     * Updates the playerRow and playerCol properties from the model.
     * Used after generation, loading, or movement.
     */
    private void updateCharacterPosition() {
        int[] pos = model.getCharacterPosition();
        playerRow.set(pos[0]);
        playerCol.set(pos[1]);
    }

    /**
     * Saves the current maze to a file.
     * @param file the destination file
     * @throws IOException if saving fails
     */
    public void saveMaze(File file) throws IOException {
        model.saveMaze(file);
    }

    /**
     * Loads a maze from a file and updates properties.
     * @param file the source file
     * @throws IOException if loading fails
     * @throws ClassNotFoundException if deserialization fails
     */
    public void loadMaze(File file) throws IOException, ClassNotFoundException {
        model.loadMaze(file);
        maze.set(model.getMaze());
        updateCharacterPosition();
    }

    /**
     * Returns the solution path generated by the model (if available).
     * @return a list of AState objects representing the solution path
     */
    public List<AState> getSolution() {
        return model.getSolution();
    }

    // === JavaFX Property Getters for Data Binding ===

    /**
     * @return property for the player's row index
     */
    public IntegerProperty playerRowProperty() {
        return playerRow;
    }

    /**
     * @return property for the player's column index
     */
    public IntegerProperty playerColProperty() {
        return playerCol;
    }

    /**
     * @return property representing the maze matrix
     */
    public ObjectProperty<int[][]> mazeProperty() {
        return maze;
    }

    /**
     * @return the goal position's row index
     */
    public int getGoalRow() {
        return model.getGoalPosition().getRowIndex();
    }

    /**
     * @return the goal position's column index
     */
    public int getGoalCol() {
        return model.getGoalPosition().getColumnIndex();
    }
}
